<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Casa Bulbo - Experiencia AR</title>
    
    <!-- Cargar Three.js y GLTFLoader desde CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.5s ease-in-out;
        }
        
        .loading-title {
            font-size: 8vw;
            margin-bottom: 10px;
            color: #ff6b00;
        }
        
        .loading-subtitle {
            font-size: 4vw;
            margin-bottom: 30px;
        }
        
        .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: #ff6b00;
            transition: width 0.3s ease-in-out;
        }
        
        .loading-text {
            font-size: 3.5vw;
            margin-bottom: 30px;
            text-align: center;
            max-width: 80%;
        }
        
        .start-button {
            padding: 15px 30px;
            background-color: #ff6b00;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 4vw;
            cursor: pointer;
            display: none;
        }
        
        #camera-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 998;
            padding: 20px;
            text-align: center;
        }
        
        #camera-permission h2 {
            font-size: 6vw;
            margin-bottom: 20px;
            color: #ff6b00;
        }
        
        #camera-permission p {
            font-size: 4vw;
            margin-bottom: 30px;
            max-width: 80%;
        }
        
        #camera-permission button {
            padding: 15px 30px;
            background-color: #ff6b00;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 4vw;
            cursor: pointer;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #video-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }
        
        #ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #target-finder {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            box-sizing: border-box;
            border: 2px dashed white;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        
        #ui-container {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .info-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            transform: translateY(100%);
            transition: transform 0.4s ease-out;
            pointer-events: auto;
            z-index: 200;
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .info-panel.visible {
            transform: translateY(0);
        }
        
        .panel-handle {
            width: 50px;
            height: 5px;
            background-color: #ddd;
            border-radius: 3px;
            margin: 10px auto;
        }
        
        .info-content {
            padding: 0 20px 20px 20px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .info-title {
            font-size: 5vw;
            margin: 10px 0;
            color: #ff6b00;
        }
        
        .info-text {
            font-size: 3.5vw;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .button-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .ui-button {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            border: none;
            cursor: pointer;
        }
        
        .ui-button:active {
            transform: scale(0.95);
        }
        
        .card-container {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .info-card {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            max-width: 250px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            display: none;
        }
        
        .info-card.visible {
            opacity: 1;
        }
        
        .card-title {
            font-size: 4vw;
            margin: 0 0 10px 0;
            color: #ff6b00;
        }
        
        .card-text {
            font-size: 3.5vw;
            line-height: 1.4;
            margin: 0;
        }
        
        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 3.5vw;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
        }
        
        .status-message.visible {
            opacity: 1;
        }
        
        .instructions-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            max-width: 80%;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        
        .instructions-container.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .instructions-text {
            font-size: 4vw;
            margin-bottom: 20px;
        }
        
        .instructions-button {
            background-color: #ff6b00;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 3.5vw;
            cursor: pointer;
        }
        
        .place-button {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff6b00;
            color: white;
            border: none;
            border-radius: 30px;
            padding: 15px 30px;
            font-size: 4.5vw;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: none;
            pointer-events: auto;
            z-index: 150;
        }
        
        .place-button:active {
            transform: translateX(-50%) scale(0.98);
        }
    </style>
</head>
<body>
    <!-- Pantalla de carga -->
    <div id="loading-screen">
        <h1 class="loading-title">Casa Bulbo</h1>
        <h2 class="loading-subtitle">Experiencia AR</h2>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <p class="loading-text" id="loading-text">Cargando recursos...</p>
        <button class="start-button" id="start-button">Iniciar Experiencia</button>
    </div>
    
    <!-- Pantalla de permisos de cámara -->
    <div id="camera-permission">
        <h2>Permiso de cámara</h2>
        <p>Necesitamos acceso a tu cámara para crear la experiencia de realidad aumentada. No almacenamos ninguna imagen.</p>
        <button id="permission-button">Permitir acceso</button>
    </div>
    
    <!-- Contenedor de canvas y vídeo -->
    <div id="canvas-container">
        <video id="video-background" autoplay playsinline></video>
        <canvas id="ar-canvas"></canvas>
        <div id="target-finder"></div>
        <button class="place-button" id="place-button">Colocar esculturas</button>
    </div>
    
    <!-- Interfaz de usuario -->
    <div id="ui-container">
        <div class="button-container">
            <button class="ui-button" id="info-button">i</button>
            <button class="ui-button" id="help-button">?</button>
        </div>
        
        <div class="card-container" id="card-container"></div>
        
        <div class="status-message" id="status-message"></div>
        
        <div class="instructions-container" id="instructions">
            <p class="instructions-text">Apunta tu cámara hacia donde deseas colocar las esculturas y pulsa el botón "Colocar esculturas".</p>
            <button class="instructions-button" id="instructions-button">Entendido</button>
        </div>
        
        <div class="info-panel" id="info-panel">
            <div class="panel-handle"></div>
            <div class="info-content">
                <h2 class="info-title">Sobre la exposición</h2>
                <p class="info-text">Esta instalación de realidad aumentada presenta esculturas digitales inspiradas en la estética del pixel art, explorando la relación entre lo digital y lo físico.</p>
                
                <h2 class="info-title">Disposición</h2>
                <p class="info-text">Las esculturas están dispuestas en un círculo alrededor del marcador central, cada una orientada hacia el exterior como se muestra en el plano de la exposición. Esta disposición invita al espectador a recorrer el espacio y experimentar las piezas desde diferentes ángulos.</p>
                
                <h2 class="info-title">Elementos visuales</h2>
                <p class="info-text">El marcador visual representa una cara pixelada rodeada por patrones geométricos coloridos, simbolizando la dualidad entre la expresión humana y la abstracción digital.</p>
                
                <h2 class="info-title">Iluminación</h2>
                <p class="info-text">La iluminación virtual ha sido diseñada específicamente para resaltar los volúmenes y texturas de las esculturas digitales, complementando la iluminación física del espacio en Casa Bulbo, Barranco.</p>
                
                <h2 class="info-title">Interacción</h2>
                <p class="info-text">Se invita a los visitantes a moverse alrededor de las piezas, observando cómo cambian según el ángulo y la distancia, creando una experiencia inmersiva que fusiona el entorno real con elementos digitales.</p>
            </div>
        </div>
    </div>
    
    <script>
        // Fix para el cargador GLTF
        THREE.GLTFLoader = function() {
            this.load = function(url, onLoad, onProgress, onError) {
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        const fileURL = URL.createObjectURL(blob);
                        
                        // Crear un modelo simple ya que no podemos cargar GLB directamente
                        console.log("Creando modelo sustituto");
                        
                        // Crear un objeto raíz
                        const scene = new THREE.Group();
                        
                        // Colorear según la posición (simular 4 modelos diferentes)
                        const colors = [0x5664ff, 0xff4545, 0x45ff45, 0xffdc45];
                        
                        // Crear la geometría básica
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        
                        // Para cada color, crear un modelo
                        colors.forEach((color, index) => {
                            // Crear un grupo para cada escultura (será clonado después)
                            const model = createModelWithColor(color);
                            
                            // Añadir al grupo raíz si es el primero
                            if (index === 0) {
                                scene.add(model);
                            }
                        });
                        
                        // Devolver el resultado
                        onLoad({ scene: scene });
                    })
                    .catch(error => {
                        console.error('Error cargando el modelo:', error);
                        if (onError) onError(error);
                    });
            };
        };
        
        // Información de las esculturas
        const sculpturesInfo = [
            {
                id: "sculpture-1",
                title: "Escultura 1",
                text: "Representa la interacción entre formas pixeladas y orgánicas, explorando la tensión entre lo digital y natural."
            },
            {
                id: "sculpture-2",
                title: "Escultura 2",
                text: "Una interpretación tridimensional de patrones de datos transformados en forma física, conectando información y materia."
            },
            {
                id: "sculpture-3",
                title: "Escultura 3",
                text: "Esta pieza examina la fragmentación y reconstrucción de la identidad en la era digital mediante geometrías pixeladas."
            },
            {
                id: "sculpture-4",
                title: "Escultura 4",
                text: "Un homenaje a la estética de los primeros videojuegos, traduciendo su lenguaje visual a un contexto espacial contemporáneo."
            }
        ];
        
        // Referencias a elementos DOM
        const loadingScreen = document.getElementById('loading-screen');
        const progressBar = document.getElementById('progress-bar');
        const loadingText = document.getElementById('loading-text');
        const startButton = document.getElementById('start-button');
        const cameraPermission = document.getElementById('camera-permission');
        const permissionButton = document.getElementById('permission-button');
        const videoBackground = document.getElementById('video-background');
        const canvas = document.getElementById('ar-canvas');
        const targetFinder = document.getElementById('target-finder');
        const placeButton = document.getElementById('place-button');
        const infoPanel = document.getElementById('info-panel');
        const infoButton = document.getElementById('info-button');
        const helpButton = document.getElementById('help-button');
        const instructionsContainer = document.getElementById('instructions');
        const instructionsButton = document.getElementById('instructions-button');
        const statusMessage = document.getElementById('status-message');
        const cardContainer = document.getElementById('card-container');
        
        // Variables de Three.js
        let renderer, scene, camera;
        let sculptureModels = [];
        
        // Variables de estado
        let modelsLoaded = false;
        let sculpturesPlaced = false;
        let currentInfoCard = null;
        
        // Simulación de carga
        function simulateLoading() {
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 5;
                if (progress >= 100) {
                    clearInterval(interval);
                    progress = 100;
                    modelsLoaded = true;
                    loadingText.textContent = "¡Recursos cargados! Listo para comenzar.";
                    startButton.style.display = "block";
                }
                progressBar.style.width = progress + "%";
            }, 100);
        }
        
        // Crear tarjetas de información
        function createInfoCards() {
            sculpturesInfo.forEach(info => {
                const card = document.createElement('div');
                card.className = 'info-card';
                card.id = info.id + '-info';
                card.innerHTML = `
                    <h3 class="card-title">${info.title}</h3>
                    <p class="card-text">${info.text}</p>
                `;
                cardContainer.appendChild(card);
            });
        }
        
        // Mostrar mensaje de estado
        function showStatus(message, duration = 3000) {
            statusMessage.textContent = message;
            statusMessage.classList.add('visible');
            
            setTimeout(() => {
                statusMessage.classList.remove('visible');
            }, duration);
        }
        
        // Mostrar tarjeta de información de escultura
        function showSculptureInfo(sculptureId) {
            // Ocultar tarjeta actual si existe
            if (currentInfoCard) {
                currentInfoCard.classList.remove('visible');
                setTimeout(() => {
                    currentInfoCard.style.display = 'none';
                }, 300);
            }
            
            // Mostrar nueva tarjeta
            const card = document.getElementById(sculptureId + '-info');
            if (card) {
                // Posicionar tarjeta en el centro de la pantalla
                card.style.top = '50%';
                card.style.left = '50%';
                card.style.transform = 'translate(-50%, -50%)';
                
                // Mostrar tarjeta
                card.style.display = 'block';
                setTimeout(() => {
                    card.classList.add('visible');
                }, 10);
                
                currentInfoCard = card;
                
                // Ocultar automáticamente después de un tiempo
                setTimeout(() => {
                    card.classList.remove('visible');
                    setTimeout(() => {
                        card.style.display = 'none';
                    }, 300);
                    currentInfoCard = null;
                }, 5000);
            }
        }
        
        // Solicitar permisos de cámara
        async function requestCameraPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: window.innerWidth },
                        height: { ideal: window.innerHeight }
                    } 
                });
                
                videoBackground.srcObject = stream;
                
                // Esperar a que el video se cargue
                await new Promise(resolve => {
                    videoBackground.onloadedmetadata = () => {
                        resolve();
                    };
                });
                
                // Mostrar el video
                videoBackground.play();
                
                // Ocultar pantalla de permisos
                cameraPermission.style.display = 'none';
                
                // Inicializar Three.js
                initThreeJS();
                
                // Mostrar interfaz AR
                targetFinder.style.display = 'block';
                placeButton.style.display = 'block';
                
                // Mostrar instrucciones
                instructionsContainer.classList.add('visible');
                
                showStatus('Listo para colocar esculturas');
                
            } catch (error) {
                console.error('Error accediendo a la cámara:', error);
                
                // Mostrar mensaje de error
                loadingText.textContent = "Error: No se pudo acceder a la cámara. " + error.message;
                loadingText.style.color = "#ff6b6b";
                
                // Ocultar pantalla de permisos
                cameraPermission.style.display = 'none';
                
                // Mostrar pantalla de carga con error
                loadingScreen.style.display = 'flex';
            }
        }
        
        // Inicializar Three.js
        function initThreeJS() {
            // Configurar renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar para mejor rendimiento
            
            // Crear escena
            scene = new THREE.Scene();
            
            // Crear cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3;
            camera.position.y = 1;
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Crear iluminación
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0xffeecc, 0.4);
            backLight.position.set(0, 0.5, -1);
            scene.add(backLight);
            
            const bottomLight = new THREE.DirectionalLight(0xccffff, 0.3);
            bottomLight.position.set(0, -0.5, 0);
            scene.add(bottomLight);
            
            // Iniciar bucle de renderizado
            animate();
            
            // Evento de redimensionamiento
            window.addEventListener('resize', onWindowResize);
        }
        
        // Crear modelos 3D
        function createModelWithColor(color) {
            // Grupo para la escultura
            const group = new THREE.Group();
            
            // Base de la escultura
            const baseGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.3
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -0.125;
            group.add(base);
            
            // Cuerpo principal de la escultura (forma de "L" pixelada)
            const bodyGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.4
            });
            
            // Crear varios cubos para formar la estructura pixelada
            const positions = [
                [0, 0, 0],     // Centro
                [0.1, 0, 0],   // Derecha
                [0, 0.1, 0],   // Arriba
                [0.1, 0.1, 0], // Diagonal
                [-0.1, 0, 0],  // Izquierda
                [0, 0, 0.1],   // Adelante
                [0, 0, -0.1]   // Atrás
            ];
            
            // Crear los cubos en las posiciones definidas
            positions.forEach(pos => {
                const cube = new THREE.Mesh(bodyGeometry, bodyMaterial);
                cube.position.set(pos[0], pos[1], pos[2]);
                cube.scale.set(0.8, 0.8, 0.8); // Hacer los cubos un poco más pequeños
                group.add(cube);
            });
            
            // Detalles (puntos de color)
            const detailGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const detailMaterials = [
                new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.8 }), // Rojo
                new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.5, metalness: 0.8 }), // Verde
                new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5, metalness: 0.8 })  // Azul
            ];
            
            // Añadir detalles en posiciones aleatorias
            for (let i = 0; i < 5; i++) {
                const detail = new THREE.Mesh(
                    detailGeometry, 
                    detailMaterials[Math.floor(Math.random() * detailMaterials.length)]
                );
                
                // Posición aleatoria dentro de los límites de la escultura
                detail.position.set(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.3
                );
                
                group.add(detail);
            }
            
            return group;
        }
        
        // Colocar esculturas 3D
        function placeModels() {
            // Ocultar indicador y botón
            targetFinder.style.display = 'none';
            placeButton.style.display = 'none';
            
            // Colores para cada escultura según la imagen referencia
            const colors = [0x5664ff, 0xff4545, 0x45ff45, 0xffdc45];
            
            // Crear esculturas según el plano proporcionado
            const positions = [
                { position: new THREE.Vector3(0, 0, -1.5), rotation: 0, id: 1 },     // Norte
                { position: new THREE.Vector3(1.5, 0, 0), rotation: -Math.PI/2, id: 2 },  // Este
                { position: new THREE.Vector3(0, 0, 1.5), rotation: Math.PI, id: 3 },     // Sur
                { position: new THREE.Vector3(-1.5, 0, 0), rotation: Math.PI/2, id: 4 }   // Oeste
            ];
            
            positions.forEach((pos, index) => {
                // Crear modelo con el color correspondiente
                const model = createModelWithColor(colors[index]);
                
                // Aplicar escala
                model.scale.set(1.5, 1.5, 1.5);
                
                // Aplicar posición
                model.position.copy(pos.position);
                
                // Aplicar rotación para que mire hacia afuera
                model.rotation.y = pos.rotation;
                
                // Guardar referencia para interactividad
                model.userData = {
                    id: "sculpture-" + pos.id,
                    index: index
                };
                
                // Añadir a la escena
                scene.add(model);
                
                // Guardar referencia
                sculptureModels.push(model);
            });
            
            // Marcar como colocadas
            sculpturesPlaced = true;
            
            // Mostrar mensaje
            showStatus('¡Esculturas colocadas! Toca para más información.', 5000);
        }
        
        // Detectar toque en esculturas
        function handleTouch(event) {
            if (!sculpturesPlaced) return;
            
            // Obtener posición del toque
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Crear raycast
            const raycaster = new THREE.Raycaster();
            const mouseVector = new THREE.Vector2(x, y);
            
            // Lanzar rayo desde la cámara
            raycaster.setFromCamera(mouseVector, camera);
            
            // Comprobar intersecciones con todos los modelos
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                // Buscar el padre (modelo completo) del objeto intersectado
                let sculptureModel = intersects[0].object;
                
                // Subir en la jerarquía hasta encontrar el objeto raíz
                while (sculptureModel.parent && sculptureModel.parent !== scene) {
                    sculptureModel = sculptureModel.parent;
                }
                
                // Verificar si tiene datos de usuario
                if (sculptureModel.userData && sculptureModel.userData.id) {
                    showSculptureInfo(sculptureModel.userData.id);
                }
            }
        }
        
        // Actualizar tamaño del renderer cuando cambia el tamaño de la ventana
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Animación
        function animate() {
            requestAnimationFrame(animate);
            
            // Renderizar escena
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // Event Listeners
        startButton.addEventListener('click', () => {
            loadingScreen.style.display = 'none';
            cameraPermission.style.display = 'flex';
        });
        
        permissionButton.addEventListener('click', () => {
            requestCameraPermission();
        });
        
        placeButton.addEventListener('click', () => {
            loadModels();
        });
        
        instructionsButton.addEventListener('click', () => {
            instructionsContainer.classList.remove('visible');
        });
        
        infoButton.addEventListener('click', () => {
            infoPanel.classList.toggle('visible');
        });
        
        helpButton.addEventListener('click', () => {
            instructionsContainer.classList.add('visible');
        });
        
        // Detectar toques en el canvas para interactuar con las esculturas
        canvas.addEventListener('click', handleTouch);
        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault(); // Prevenir zoom u otras acciones del navegador
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                const simulatedEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                handleTouch(simulatedEvent);
            }
        });
        
        // Función para mover la cámara (navegación simplificada)
        function setupCameraMovement() {
            let isDragging = false;
            let previousMousePosition = {
                x: 0,
                y: 0
            };
            
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging || !sculpturesPlaced) return;
                
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                // Mover la cámara en círculo alrededor del centro
                const rotationSpeed = 0.005;
                
                // Crear punto central de la escena
                const center = new THREE.Vector3(0, 0, 0);
                
                // Calcular vector de la cámara al centro
                const direction = new THREE.Vector3().subVectors(center, camera.position).normalize();
                
                // Calcular vector perpendicular (derecha)
                const right = new THREE.Vector3().crossVectors(camera.up, direction).normalize();
                
                // Rotar alrededor del eje vertical
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -deltaMove.x * rotationSpeed);
                
                // Actualizar la dirección de la cámara
                camera.lookAt(center);
                
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            });
            
            // Soporte para toques en móviles
            canvas.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                }
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('touchmove', (event) => {
                if (!isDragging || !sculpturesPlaced || event.touches.length !== 1) return;
                
                const deltaMove = {
                    x: event.touches[0].clientX - previousMousePosition.x,
                    y: event.touches[0].clientY - previousMousePosition.y
                };
                
                // Mover la cámara en círculo alrededor del centro
                const rotationSpeed = 0.005;
                
                // Crear punto central de la escena
                const center = new THREE.Vector3(0, 0, 0);
                
                // Rotar alrededor del eje vertical
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -deltaMove.x * rotationSpeed);
                
                // Actualizar la dirección de la cámara
                camera.lookAt(center);
                
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            });
        }
        
        // Cargar modelo 3D desde repositorio
        function loadModels() {
            // Mostrar progreso de carga
            showStatus('Cargando modelo 3D...', 10000);
            
            // URL del modelo en repositorio
            const modelUrl = 'https://cdn.glitch.global/2b60304b-b88f-4fb9-b962-fddf642554cd/E1.glb?v=1746329999294';
            
            // Crear el cargador GLTF
            const loader = new THREE.GLTFLoader();
            
            // Si THREE.GLTFLoader no está disponible, usar geometrías básicas
            if (!loader) {
                console.error('GLTFLoader no disponible, usando geometrías básicas');
                placeModels();
                return;
            }
            
            // Cargar el modelo
            loader.load(
                // URL del modelo
                modelUrl,
                
                // Callback de éxito
                function(gltf) {
                    console.log('Modelo cargado correctamente');
                    showStatus('Modelo cargado correctamente');
                    
                    // Guardar el modelo original para clonarlo después
                    const originalModel = gltf.scene;
                    
                    // Escalar el modelo a un tamaño adecuado
                    originalModel.scale.set(0.05, 0.05, 0.05);
                    
                    // Ocultar indicador y botón
                    targetFinder.style.display = 'none';
                    placeButton.style.display = 'none';
                    
                    // Crear esculturas según el plano proporcionado
                    const positions = [
                        { position: new THREE.Vector3(0, 0, -1.5), rotation: 0, id: 1 },           // Norte
                        { position: new THREE.Vector3(1.5, 0, 0), rotation: -Math.PI/2, id: 2 },   // Este
                        { position: new THREE.Vector3(0, 0, 1.5), rotation: Math.PI, id: 3 },      // Sur
                        { position: new THREE.Vector3(-1.5, 0, 0), rotation: Math.PI/2, id: 4 }    // Oeste
                    ];
                    
                    positions.forEach((pos, index) => {
                        // Clonar el modelo
                        const model = originalModel.clone();
                        
                        // Aplicar posición
                        model.position.copy(pos.position);
                        
                        // Aplicar rotación para que mire hacia afuera
                        model.rotation.y = pos.rotation;
                        
                        // Guardar referencia para interactividad
                        model.userData = {
                            id: "sculpture-" + pos.id,
                            index: index
                        };
                        
                        // Añadir a la escena
                        scene.add(model);
                        
                        // Guardar referencia
                        sculptureModels.push(model);
                    });
                    
                    // Marcar como colocadas
                    sculpturesPlaced = true;
                    
                    // Mostrar mensaje
                    showStatus('¡Esculturas colocadas! Toca para más información.', 5000);
                },
                
                // Callback de progreso
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% cargado');
                },
                
                // Callback de error
                function(error) {
                    console.error('Error cargando el modelo:', error);
                    showStatus('Error cargando modelo 3D. Usando alternativa.', 3000);
                    
                    // Si hay error, usar el método de geometrías básicas
                    placeModels();
                }
            );
        }
        
        // Inicializar la aplicación
        function init() {
            // Simular carga
            simulateLoading();
            
            // Crear tarjetas de información
            createInfoCards();
            
            // Configurar movimiento de cámara
            setupCameraMovement();
        }
        
        // Iniciar la aplicación
        init();
    </script>
</body>
</html>